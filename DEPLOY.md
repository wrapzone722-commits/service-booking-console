# Деплой: Git → Timeweb Cloud (App Platform, Docker)

Проект подготовлен к деплою через Git-репозиторий в **Timeweb Cloud App Platform** с использованием **Dockerfile**.

## Настройка Git push (один раз)

Чтобы `git push origin main` работал без запроса пароля, один раз выполните в корне проекта (подставьте свой GitHub Personal Access Token вместо `YOUR_TOKEN`):

```bash
git remote set-url origin "https://wrapzone722-commits:YOUR_TOKEN@github.com/wrapzone722-commits/service-booking-console.git"
```

Токен хранится только в локальном `.git/config` и не коммитится. **Не добавляйте токен в файлы репозитория.** Если токен утёк — отзовите его в GitHub (Settings → Developer settings → Personal access tokens) и создайте новый.

## Timeweb MCP сервер

В Cursor подключён **MCP сервер Timeweb** (`user-timeweb-mcp-server`). Через него можно создавать приложения в Timeweb Cloud без ручного ввода в панели.

**Инструменты:**
- **get_vcs_providers** — список подключённых VCS (GitHub, GitLab и т.д.)
- **get_vcs_provider_repositories** (provider_id) — список репозиториев провайдера
- **get_vcs_provider_by_repository_url** (repository_url) — найти провайдер по URL репозитория
- **get_allowed_presets** — доступные пресеты (конфигурации сервера)
- **get_deploy_settings** — настройки деплоя по умолчанию для фреймворков
- **add_vcs_provider** — добавить VCS провайдер
- **create_timeweb_app** — создать приложение (тип, репозиторий, framework: **docker**, build_cmd, run_cmd, envs и т.д.)

**Для этого проекта (Docker):** при создании приложения через MCP укажите `type: backend`, `framework: docker`. Репозиторий: `https://github.com/wrapzone722-commits/service-booking-console`, ветка `main`.

**Если MCP выдаёт «Не удалось найти VCS провайдер для репозитория»:** провайдер и репозиторий при этом могут быть в списке (get_vcs_providers / get_vcs_provider_repositories). Создайте приложение **вручную** в панели Timeweb (см. блок ниже «Параметры для ручного создания»).

**Настройка API-токена (чтобы убрать 401):**  
1. В Cursor откройте **Settings** → **Tools & MCP** → сервер **timeweb-mcp-server**.  
2. В конфигурации сервера добавьте переменную окружения с API-ключом Timeweb (JWT). Обычно это `TIMEWEB_API_TOKEN` или `API_KEY` — см. документацию timeweb-mcp-server.  
3. В значение вставьте ваш JWT-токен из панели Timeweb Cloud (раздел API / Ключи доступа).  
4. Сохраните настройки и при необходимости перезапустите MCP-сервер. После этого вызовы `get_vcs_providers`, `create_timeweb_app` и др. будут проходить без 401.

## Что уже настроено

- **Dockerfile** — мультистейдж-сборка (Node 20 Alpine): сборка клиента и сервера, затем минимальный runtime-образ.
- **pnpm** — в образе используется pnpm (как в проекте).
- **Порт** — приложение слушает `PORT` (по умолчанию 3000). Платформа может задать свой порт через переменную окружения.
- **Health check** — эндпоинт `GET /health` возвращает `200 OK`; в образе настроен `HEALTHCHECK` для проверки живости контейнера.
- **.dockerignore** — в контекст сборки не попадают `node_modules`, `dist`, `.env`, лишние файлы (включая папку `server` в контексте не исключаем — она нужна для сборки).
- **.gitignore** — `.env` и `.env.*` не коммитятся; в репозиторий можно положить только `.env.example`.

## Шаги деплоя

### 1. Репозиторий в Git

```bash
git init
git add .
git commit -m "Prepare for deploy"
git remote add origin <URL вашего репозитория>
git push -u origin main
```

Убедитесь, что в репозитории **нет** файла `.env` (он в `.gitignore`).

### 2. Timeweb Cloud App Platform

**Параметры для ручного создания (если MCP не сработал):**

| Параметр | Значение |
|----------|----------|
| Репозиторий | `https://github.com/wrapzone722-commits/service-booking-console` |
| Ветка | `main` |
| Тип приложения | **Dockerfile** (не автоопределение) |
| Dockerfile | в корне репозитория |
| Пресет | любой backend (например, 2 GB RAM) |
| Переменные | `PORT`, `JWT_SECRET`, при необходимости — из `.env.example` |

1. В панели Timeweb Cloud откройте **App Platform** (или раздел деплоя приложений).
2. Создайте новое приложение, выберите источник **Git** и укажите ваш репозиторий и ветку (например, `main`).
3. **Важно:** в шаге «Тип» сразу перейдите на вкладку **Dockerfile** и выберите её — не используйте автоопределение, иначе может появиться ошибка «Не удалось сформировать рекомендации».  
   Путь к Dockerfile — корень репозитория (файл `Dockerfile` в корне).
4. Порт: укажите переменную окружения **`PORT`** (часто платформа сама подставляет порт, например 8080 или 3000). Приложение читает `process.env.PORT`.
5. Добавьте переменные окружения из `.env.example` в настройках приложения (секреты не коммитить). **Минимум для запуска:** `NODE_ENV=production`, `JWT_SECRET` (обязательно свой секрет), `API_BASE_URL` (полный URL вашего API, например `https://your-domain.com/api/v1`).
   - `NODE_ENV=production`
   - `JWT_SECRET` — обязательно задать свой секрет
   - `API_BASE_URL` — URL, на котором доступен API (для QR и писем)
   - `DATABASE_URL` — если используется БД
   - `YANDEX_CLIENT_ID`, `YANDEX_CLIENT_SECRET`, `YANDEX_REDIRECT_URI` — для OAuth
   - `TELEGRAM_BOT_TOKEN`, `TELEGRAM_BOT_USERNAME` — для кнопки «Вход через Telegram»
   - `API_BASE_URL`, SMTP, SMS и т.д. — по необходимости
6. Запустите сборку и деплой. Платформа соберёт образ по Dockerfile и запустит контейнер.

### 3. Проверка после деплоя

- Откройте URL приложения — должна открыться SPA.
- Проверьте API: `https://<ваш-домен>/api/ping`.
- Проверьте health: `https://<ваш-домен>/health` — ответ `{"status":"ok"}`.
- На странице входа внизу должна быть строка **«v2.1 • build 2025-02»** — если видите её, загружена новая сборка.

### После деплоя не вижу изменений

1. **Пересоберите приложение**  
   В панели Timeweb (или вашего хостинга) откройте приложение → **«Пересобрать»** / **«Redeploy»**. Убедитесь, что сборка идёт с ветки **main** и с последнего коммита (в логах сборки должен быть ваш последний commit).

2. **Жёсткое обновление страницы**  
   Браузер может отдавать старый JS/CSS из кэша. Нажмите **Ctrl+Shift+R** (Windows/Linux) или **Cmd+Shift+R** (Mac), либо откройте сайт в режиме **инкогнито**.

3. **Проверьте логи сборки**  
   Если сборка падает (например, ошибка с `nodemailer` или другими зависимостями), на сервере продолжит работать старая версия. Исправьте ошибки по логам и пересоберите.

4. **Проверьте версию на странице входа**  
   Внизу страницы входа есть строка вида **«v2.1 • build 2025-02»**. Если видите её — загружена новая сборка. Если нет — всё ещё кэш или старая сборка.

## Локальная проверка Docker-образа

```bash
pnpm build
docker build -t servicebooking:local .
docker run -p 3000:3000 -e JWT_SECRET=test-secret servicebooking:local
```

В браузере: http://localhost:3000 и http://localhost:3000/health.

## Переменные окружения (кратко)

| Переменная           | Описание                    |
|----------------------|-----------------------------|
| `PORT`               | Порт сервера (по умолчанию 3000) |
| `NODE_ENV`           | Обычно `production`         |
| `JWT_SECRET`         | Секрет для JWT (обязательно) |
| `DATABASE_URL`       | URL PostgreSQL (если нужна БД) |
| `API_BASE_URL`       | Базовый URL API для фронта  |
| `YANDEX_*`           | OAuth Яндекса               |
| `SMS_API_KEY`        | api_id с SMS.ru для кодов   |
| `SMS_SENDER`         | Имя отправителя SMS         |

Полный список и пример — в `.env.example`.

## Верификация по коду (без затрат или через SMS)

На странице входа есть способ **«Вход по коду (без SMS — код на экране)»**: пользователь вводит номер телефона, нажимает «Отправить код» — код появляется **на экране** (верификация без затрат). Пользователь вводит код и входит; аккаунт создаётся при первом входе.

**Без настройки (бесплатно):** не задавайте `SMS_API_KEY` — код показывается на экране после «Отправить код». Подходит для демо и тестов.

**С SMS (оплата у провайдера):** задайте `SMS_API_KEY` (api_id с [SMS.ru](https://sms.ru)) и `SMS_SENDER` — тогда код уходит в SMS на указанный номер. Мастер-код (`SECRET_VERIFICATION_CODE`, по умолчанию **0000**) обеспечивает вход без проверки кода.

## Ошибка «Не удалось сформировать рекомендации»

Это сообщение выдаёт сама платформа Timeweb при попытке **автоопределить** тип приложения по репозиторию. Обход без ожидания рекомендаций:

1. **Сразу выбрать тип «Dockerfile»**  
   При создании приложения в шаге «Тип» перейдите на вкладку **Dockerfile** и выберите её. Не используйте автоопределение — тогда этап «рекомендаций» не нужен.

2. **Подключить репозиторий по URL**  
   Если приложение создаётся через «Подключить Git» и что-то падает на этапе анализа:
   - Нажмите «Подключить git-репозиторий по URL».
   - Укажите URL репозитория, например:  
     `https://github.com/wrapzone722-commits/service-booking-console.git`
   - Ветка: `main`.
   - Тип: **Dockerfile** (вкладка Dockerfile).

3. **Проверить требования к Dockerfile**  
   В корне репозитория должен быть файл **Dockerfile**. В нём должен быть указан **EXPOSE** (у нас `EXPOSE 3000`). Тогда платформа знает порт без «рекомендаций».

4. **Повторить позже или написать в поддержку**  
   Если ошибка появляется даже при явном выборе Dockerfile, подождите и запустите деплой снова или обратитесь в поддержку Timeweb Cloud — возможно, сбой на стороне платформы.

**Кратко:** не полагайтесь на автоопределение — при создании приложения сразу выберите тип **Dockerfile** и при необходимости подключите репозиторий по URL.

---

## «Не удаётся установить соединение» / «Время ожидания ответа истекло»

Если браузер пишет, что не удаётся установить соединение или время ожидания истекло:

1. **Проверить логи приложения в Timeweb**  
   Приложение → вкладка «Логи» или «Сборки» → последняя сборка и логи контейнера. Должны быть строки: `Fusion Starter server running on port …`, `SPA: /app/dist/spa`. Если логов нет или контейнер постоянно перезапускается — приложение падает при старте (смотрите текст ошибки в логах).

2. **Порт**  
   В настройках приложения должна быть переменная **`PORT`** (часто Timeweb подставляет свой порт, например 8080). Приложение читает `process.env.PORT` и слушает на **0.0.0.0** (доступ снаружи контейнера). Если в настройках указан другой порт для входящего трафика — он должен совпадать с тем, на котором слушает приложение.

3. **Health check**  
   В настройках приложения путь проверки состояния — **`/health`**. Эндпоинт возвращает `200 OK`. Если health check падает, платформа может не направлять трафик на контейнер.

4. **Сборка**  
   Убедитесь, что последняя сборка **успешна** (зелёный статус). Если сборка падает, новый контейнер не запускается и сайт недоступен.

5. **Повторить позже / поддержка**  
   Если логи в порядке, порт и health check настроены — подождите 2–5 минут после деплоя или обратитесь в поддержку Timeweb Cloud (возможны задержки выдачи DNS или балансировщика).

---

## Сервер стартует, затем «Received SIGTERM, shutting down gracefully»

Если в логах видно: приложение запустилось (`Fusion Starter server running on port 3000`, `SPA: /app/dist/spa`), а через несколько секунд — `Received SIGTERM, shutting down gracefully`, платформа завершает контейнер, считая его «нездоровым».

**Частая причина:** платформа делает health check на **другом порту** (например 8080), а приложение слушает 3000. Проверка не проходит → платформа шлёт SIGTERM.

**Что сделать:**

1. В настройках приложения в Timeweb задайте переменную **`PORT`** равной порту, который платформа использует для трафика и проверки (часто это **8080**).  
   Пример: **`PORT=8080`**.  
   Приложение подхватит `process.env.PORT` и будет слушать на 8080 — health check и маршрутизация начнут работать.

2. В настройках приложения проверьте, что указаны:
   - **Порт контейнера** (или «Порт приложения») — тот же, что и `PORT` (например 8080).
   - **Путь проверки состояния** — **`/health`**.

3. Пересоберите/перезапустите приложение и снова посмотрите логи — должна быть строка вида `Fusion Starter server running on port 8080` (или другой заданный порт), и контейнер не должен получать SIGTERM сразу после старта.

---

## «Этот сайт не может обеспечить безопасное соединение» / «недействительный ответ»

Если браузер пишет, что сайт (например, `*.twc1.net`) отправил недействительный ответ или не может обеспечить безопасное соединение:

1. **Подождать выпуск SSL-сертификата**  
   После первого деплоя Let's Encrypt может выпускать сертификат 5–15 минут. Подождите и обновите страницу через несколько минут. В панели Timeweb проверьте, что у приложения есть привязка домена и статус сертификата.

2. **Проверить логи приложения**  
   В панели Timeweb откройте приложение → вкладка «Логи» или «Деплой». Убедитесь, что контейнер запущен и в логах есть строка вида `Fusion Starter server running on port …`. Если приложение падает при старте или постоянно перезапускается, исправьте ошибки по логам (например, отсутствующие переменные, порт).

3. **Порт контейнера**  
   Приложение слушает порт из переменной **`PORT`** (по умолчанию 3000). В настройках приложения не должно быть конфликта: если платформа передаёт `PORT=8080`, приложение поднимется на 8080. Не удаляйте переменную `PORT`, если её задаёт платформа.

4. **Открывать по HTTPS**  
   Используйте в адресной строке **`https://`** (не `http://`), например:  
   `https://wrapzone722-commits-service-booking-console-9d36.twc1.net`

5. **Проверить без HTTPS (если платформа даёт HTTP)**  
   Если в панели указан домен без HTTPS или есть отдельная ссылка по HTTP — откройте её. Если по HTTP сайт открывается, а по HTTPS — «недействительный ответ», проблема в SSL (подождать выпуск сертификата или написать в поддержку Timeweb).

6. **Обратиться в поддержку Timeweb Cloud**  
   Если через 15–20 минут после деплоя ошибка остаётся, пришлите в поддержку домен приложения и скрин/текст ошибки — они проверят выпуск сертификата и прокси.

---

## Troubleshooting

- **Сборка падает в Docker** — проверьте, что в репозитории есть папки `client/`, `server/`, `shared/` и файлы `vite.config.ts`, `vite.config.server.ts`.
- **502 / контейнер падает** — проверьте логи в панели; убедитесь, что заданы обязательные переменные (например, `JWT_SECRET`) и что приложение слушает `PORT`, который задаёт платформа.
- **Health check failed** — в настройках приложения укажите путь проверки состояния **`/health`** (или оставьте HEALTHCHECK из Dockerfile). Убедитесь, что эндпоинт возвращает код 2xx.
